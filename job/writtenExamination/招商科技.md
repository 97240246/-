#### 招商科技笔试（2021/2/28--测试开发工程师）

> 题型主要有单选、填空、简答和编程题，根据我的回忆列出来下面的题

##### 单选题

- 1.考察"="赋值运算符号的运算顺序，= 的运算顺序是从右向左运算

   题目： 

  ```
  int x =10;
  x += x -= x - x;
  ```

  经过上述运算后，x的值为20。

  解题步骤：

   先看： x -= x - x，这个式子等于：

    x = x - (x - x); 得到的结果为 x == 10

   在计算 x += x，这个式子等于：

   x = x + x; 得到的结果为x == 20

- 2.考察了进程和线程的关系以及分别的特性

   1.调度：线程作为调度和分配的基本单位，**进程作为拥有资源的基本单位**（线程没有虚拟地址）

   2.并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行

   3.拥有资源：进程是拥有资源的一个独立单位，进程之间的资源是独立的，线程不拥有系统资源，但可以访问隶属于进程的资源

   4.地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间

   5.系统开销：在创建或撤销进程的时候，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或者撤销线程时的开销。        但进程有独立的空间地址，进程崩溃后，在保护模式下不会对其他进程产生影响，而线程只是一个进程中不同的执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但是在进程切换时，耗费的资源较大，效率较差。

   6.执行过程：每个独立的进程程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制

   7.线程是处理器调度的基本单位，但是进程不是

   8.两者均可并发执行

- 3.线程的几种状态

   1.新建：新创建了一个线程对象

   2.就绪：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于“可运行线程池中”，变得可运行，只等待获取CPU 的试用权，即在就绪状态的进程除了CPU之外，其他运行的所需资源已经全部获得

   3.运行：救赎状态的线程获得了CPU，执行程序代码

   4.阻塞：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程再次进入就绪状态，线程才会重新运行

  ​      阻塞的情况又分为3种：

  ​         (1).等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入等待池中，进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用的notify()或者notifyAll()方法才能被唤醒

  ​         (2).同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中

  ​         (3).其他阻塞：运行的线程执行sleep()或者join()方法，或者发出I/O请求时，JVM会把该线程置为阻塞状态，当sleep()超时、join()等待线程终止或者超时、I/O处理完毕时，线程就重新进入就绪状态

   5.死亡：线程执行完了或者因异常退出了run()方法，该线程结束生命周期

- HTTP的常见的状态码含义

  ![](..\..\pictures\job\write\HTTP状态码.jpg)

##### 填空题

- 1.浏览器的同源策略

​     同源策略的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页"同源"。所谓"同源"指的是"三个相同"。

```
- 协议相同
- 域名相同
- 端口相同
```

- 2.HTTP请求包含的三个部分：

  ​       请求行+请求头 + 数据体（请求体）

​           HTTP响应包含的三个部分：

​              响应行+响应头 + 响应体

##### SQL题目

有两个表，分别是

student(sid,sname,ssex)

score(cid,sid,score)

- 找到所有科目均及格的学生信息

  ```sql
  select * from student where sid in (select sid from group by sid having min(score) > 60);
  ```

- 第二题记不太清了

##### 简答题

1.教授选出两个从2到9的数，把它们的和告诉学生甲，把它们的积告诉学生乙，让他们轮流猜这两个数。

甲说：“我猜不出”
乙说：“我猜不出”
甲说：“我猜到了”
乙说：“我也猜到了”

你猜到这两个数是多少吗？



解答步骤：

- 【2，9】之间不可重复的两个数

首先，我们来把乘积唯一的去掉，因为那样的话，乙一开始就知道是哪两个数了，我用红线删掉了。这时就只剩先乘积是12、18和24的6组数了。（2 6 ，3 4 ，3 6 ， 2 9 ，3 8 ，4 6）

第二步，我们来把有相同和的再去掉，因为此时甲说他知道了，所以答案的那组数的和必须是唯一的，我用蓝线去掉了（2，9）和（3，8），现在剩下4组数了。这时候乙的确是已经知道答案了，因为他是知道两个数的和的，只是我们还不能确定。

第三步，我们再来把乘积一样的数去掉，因为乙也说他知道了，我用绿线去掉了（2，6）和（3，4），此时因为乙也是拿到了乘积的，所以他知道答案。

由于我们没有更多的信息了，所以剩下的都有可能是答案（3，6）和（4，6）

（3，6）时，甲知道的数是9，乙知道的数是18

（4，6）时，甲知道的数是10，乙知道的数是24

- 【2，9】之间可重复的两个数

重复上面的步骤。

首先，我们用红线来把乘积唯一的去掉。这时剩下10组数。

第二步，我们用蓝线来把和相同的再去掉，现在剩下4组数了。

第三步，我们用绿线来把乘积一样的数去掉，也是剩下两组数。

由于我们没有更多的信息了，所以剩下的都有可能是答案（3，4）和（3，6）

（3，4）时，甲知道的数是7，乙知道的数是12

（3，6）时，甲知道的数是9，乙知道的数是18



2.UI自动化时，因为程序界面经常变化导致自动化测试用例成本维护难度大，那么我们应该怎么设计自动化测试用例呢?

这道题也是我目前迷惑的，后面上班想想。

##### 程序题

- 输入年月日时间判断是这年的第几天

   这道题的重点就是判断这一年是不是闰年：

  ```java
   if((year % 4 == 0 && year % 100 != 0)||(year % 400 == 0)){
                  towMonth = 29;//闰年多一天
              }
  ```

- 电话号码的字母组合，这道题是Leecode的原题

  ```java
  //给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 
  //
  // 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 
  //
  // 
  //
  // 示例: 
  //
  // 输入："23"
  //输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
  // 
  //
  // 说明: 
  //尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 
  // Related Topics 字符串 回溯算法 
  // 👍 806 👎 0
  
  
  
  
  import java.util.ArrayList;
  
  //leetcode submit region begin(Prohibit modification and deletion)
  class Solution {
      public List<String> letterCombinations(String digits) {
          List<String> res = new ArrayList<>();
          if (digits == null || digits.length() == 0) return res;
          permute(res, digits, new StringBuilder());
          return res;
      }
  
      private void permute(List<String> res, String digits, StringBuilder sb) {
          if (digits.length() == 0) {
              res.add(sb.toString());
              return;
          }
          for (char c : getChars(digits.charAt(0))) {
              sb.append(c);
              permute(res, digits.substring(1), sb);
              sb.deleteCharAt(sb.length() - 1); // 回溯主要体现在这部分
          }
      }
  
      private char[] getChars(char c) {
          switch (c) {
              case '2':
                  return new char[]{'a', 'b', 'c'};
              case '3':
                  return new char[]{'d', 'e', 'f'};
              case '4':
                  return new char[]{'g', 'h', 'i'};
              case '5':
                  return new char[]{'j', 'k', 'l'};
              case '6':
                  return new char[]{'m', 'n', 'o'};
              case '7':
                  return new char[]{'p', 'q', 'r', 's'};
              case '8':
                  return new char[]{'t', 'u', 'v'};
              case '9':
                  return new char[]{'w', 'x', 'y', 'z'};
              default:
                  return new char[0];
          }
      }
  }
  ```

  

- 全排列，这道题也是Leecode原题

  ```java
  //给定一个 没有重复 数字的序列，返回其所有可能的全排列。
  ////
  // 示例: 
  //
  // 输入: [1,2,3]
  //输出:
  //[
  //  [1,2,3],
  //  [1,3,2],
  //  [2,1,3],
  //  [2,3,1],
  //  [3,1,2],
  //  [3,2,1]
  //] 
  // Related Topics 回溯算法
  // 👍 837 👎 0
  
  
  List<List<Integer>> res = new LinkedList<List<Integer>>();//使用全局变量res保存结果
  
      /* 主函数，输⼊⼀组不重复的数字，返回它们的全排列 */
      List<List<Integer>> permute(int[] nums) {
          // 记录「路径」
          LinkedList<Integer> track = new LinkedList<Integer>();
          boolean[] used = new boolean[nums.length];
          backtrack(nums, track,used);
          return res;
      }
      // 路径：记录在 track 中
  // 选择列表：nums 中不存在于 track 的那些元素
  // 结束条件：nums 中的元素全都在 track 中出现
      void backtrack(int[] nums, LinkedList<Integer> track,boolean[] used) {
          // 触发结束条件
          if (track.size() == nums.length) {
              //运行到这里后会进入return这行，运行完这行之后会把track里的最后一个元素remove
              //所以这里new了一个linkedlist并且add到res里面去
              res.add(new LinkedList<Integer>(track));
              return;
          }
          for (int i = 0; i < nums.length; i++) {
              
              // 有重复数据的话，打开这个if判断
              //if (i > 0 && nums[i] == nums[i - 1] && used[i - 1]) {
              //    continue;
              //}
              // 排除不合法的选择
  //            if (track.contains(nums[i]))//这里可以优化
              if (used[i])
                  continue;
              // 做选择
              track.add(nums[i]);
              used[i] = true;
              // 进⼊下⼀层决策树
              backtrack(nums, track,used);
              // 取消选择
              track.removeLast();
              used[i] = false;
          }
      }
  ```
  
  
  
  